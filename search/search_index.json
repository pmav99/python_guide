{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Suggestions for Python Development on Linux \u00b6 tl;dr \u00b6 The suggested setup is: Linux setup the environment in a reproducible way (e.g. using docker , ansible , conda , etc) Use a modern python version (3.6+) Create a virtualenv manage the python dependencies with poetry [Ooptional] install python cli applications using pipx Disclaimer \u00b6 First of all, a couple of definitions: A library is a provider of an API, i.e. code that gets imported by other libraries or applications An application is a consumer of APIs, i.e. code that imports other libraries The suggestions in this document are written from the point of view of the application developer. The requirements for library developers are different (more complex). Note: Obviously, the distinction made here is quite high level. You can have code that is both a library and an application, you can have a library where only part of the APi is public while the rest of the code is not meant to be imported, etc The reason we make this distinction is that in an application you only care for your code to be running with a specific python version. On the other hand, in a library you must e.g. avoid pinning your requirements to specific versions, test with multiple python versions etc.","title":"Home"},{"location":"#suggestions-for-python-development-on-linux","text":"","title":"Suggestions for Python Development on Linux"},{"location":"#tldr","text":"The suggested setup is: Linux setup the environment in a reproducible way (e.g. using docker , ansible , conda , etc) Use a modern python version (3.6+) Create a virtualenv manage the python dependencies with poetry [Ooptional] install python cli applications using pipx","title":"tl;dr"},{"location":"#disclaimer","text":"First of all, a couple of definitions: A library is a provider of an API, i.e. code that gets imported by other libraries or applications An application is a consumer of APIs, i.e. code that imports other libraries The suggestions in this document are written from the point of view of the application developer. The requirements for library developers are different (more complex). Note: Obviously, the distinction made here is quite high level. You can have code that is both a library and an application, you can have a library where only part of the APi is public while the rest of the code is not meant to be imported, etc The reason we make this distinction is that in an application you only care for your code to be running with a specific python version. On the other hand, in a library you must e.g. avoid pinning your requirements to specific versions, test with multiple python versions etc.","title":"Disclaimer"},{"location":"01_why_linux/","text":"The choice of the operating system is for sure a controversial topic. Among other things it is a question of aeshetics, specific needs and it often boils down just to personal preference. Nevertheless, I am arguing that when it comes to Python there usually is enough justification to choose Linux over other OSes. Note For sure, any modern operating system can server your needs. The question what is the best way to serve your (programming) needs. Tip In this guide I am only describing what works for me. You should choose the OS that is serving your needs in the best possible way. dev vs prod \u00b6 An important distinction is between: the development environment (i.e. where you write the code) the production environment (i.e. where you run the code) In order to make debugging easier, you should strive to make the development environment as similar as possible to the production environment. Why Linux? \u00b6 As far as I am concerned, I consider myself I professional. When it comes to my work I want to be using the best tools I can, no questions asked. Just to give you a few examples: There is a great deal of unix tools that make development so much easier and which are not available on Windows. Some of them are available on Mac OS, but not all; see the next point. Not having native docker is a huge deal breaker for me. It is not that it doesn't work on other operating systems, but as soon as you move on from simple cases you will eventually encounter a bug or some incompatibility and you will have to start jumping through hoops. Practically speaking, in science and web-development, the vast majority of the code that you will write will be executed on Linux (HPC, HTC, super-computers, web servers etc). Remember what we said about minimizing the differences between dev and prod ? There is some truth in (big) numbers. 1 in 4 developers use Linux (regardless of Programming Language). When it comes to developers that identify themselves as primarily Python devs, 70% of them use Linux at some capacity (main OS or cnotainers). Note Is the Linux world a fairy-tale? Nope! E.g. when it comes to multimedia it is a living hell . But here we are talking about development. Not about watching movies, using bluetooth devices etc. Why not Mac? \u00b6 It is unix based. It is very polished when it comes to integration with the native applications. Many devs like Mac OS. Nevertheless, it is like Linux. It is not Linux. Note I spend most of my working time in front of a console and linux is better at that. Why not windows? \u00b6 In the past, Python on Widows was really a second class citizen. Nowadays, with platforms like conda the situation is for sure better, nevertheless there are still restrictions. For example: Eventually you will need something that is not available via a pre-compiled package and compiling C-Extentions on Windows is a major PITA. Dealing with multi-processing and multi-threading on windows is not what you call fun. There are a lot of subtle details that are different than Linux and usually that's where you will run your code. How about VMs and WSL? \u00b6 There are two more options: Using Windows or Mac as the host operating system and using Linux in a Virtual Machine (VM) Using Windows Subsystem for Linux (WSL) For a short period, I did use a VM and someone whose opinion I value uses it extensively . In the past (2000s) when computers were much weaker it was not really a viable choice. Nowadays, it works just fine though. Personally I haven't used WSL. I know that it is being actively developed/improved. It is for sure a technology worth keeping our eyes upon. As of today, between the two, I think I would choose a VM.","title":"Why Linux?"},{"location":"01_why_linux/#dev-vs-prod","text":"An important distinction is between: the development environment (i.e. where you write the code) the production environment (i.e. where you run the code) In order to make debugging easier, you should strive to make the development environment as similar as possible to the production environment.","title":"dev vs prod"},{"location":"01_why_linux/#why-linux","text":"As far as I am concerned, I consider myself I professional. When it comes to my work I want to be using the best tools I can, no questions asked. Just to give you a few examples: There is a great deal of unix tools that make development so much easier and which are not available on Windows. Some of them are available on Mac OS, but not all; see the next point. Not having native docker is a huge deal breaker for me. It is not that it doesn't work on other operating systems, but as soon as you move on from simple cases you will eventually encounter a bug or some incompatibility and you will have to start jumping through hoops. Practically speaking, in science and web-development, the vast majority of the code that you will write will be executed on Linux (HPC, HTC, super-computers, web servers etc). Remember what we said about minimizing the differences between dev and prod ? There is some truth in (big) numbers. 1 in 4 developers use Linux (regardless of Programming Language). When it comes to developers that identify themselves as primarily Python devs, 70% of them use Linux at some capacity (main OS or cnotainers). Note Is the Linux world a fairy-tale? Nope! E.g. when it comes to multimedia it is a living hell . But here we are talking about development. Not about watching movies, using bluetooth devices etc.","title":"Why Linux?"},{"location":"01_why_linux/#why-not-mac","text":"It is unix based. It is very polished when it comes to integration with the native applications. Many devs like Mac OS. Nevertheless, it is like Linux. It is not Linux. Note I spend most of my working time in front of a console and linux is better at that.","title":"Why not Mac?"},{"location":"01_why_linux/#why-not-windows","text":"In the past, Python on Widows was really a second class citizen. Nowadays, with platforms like conda the situation is for sure better, nevertheless there are still restrictions. For example: Eventually you will need something that is not available via a pre-compiled package and compiling C-Extentions on Windows is a major PITA. Dealing with multi-processing and multi-threading on windows is not what you call fun. There are a lot of subtle details that are different than Linux and usually that's where you will run your code.","title":"Why not windows?"},{"location":"01_why_linux/#how-about-vms-and-wsl","text":"There are two more options: Using Windows or Mac as the host operating system and using Linux in a Virtual Machine (VM) Using Windows Subsystem for Linux (WSL) For a short period, I did use a VM and someone whose opinion I value uses it extensively . In the past (2000s) when computers were much weaker it was not really a viable choice. Nowadays, it works just fine though. Personally I haven't used WSL. I know that it is being actively developed/improved. It is for sure a technology worth keeping our eyes upon. As of today, between the two, I think I would choose a VM.","title":"How about VMs and WSL?"},{"location":"02_reproducible_environment/","text":"Reproducible environments \u00b6 What is an environment? \u00b6 In the context we are discussing, setting up the environment means to make sure that all the non-python programs and libraries that you application needs are available. So, if your code is calling for example gdalinfo or pdflatex using subprocess , it is your job to make sure that the program is there. A crucial detail is that the environment should be reproducible . And this affects both the development environment and the production environment Setup a reproducible environment \u00b6 Reproducible dev-environments mean that in case: your laptop breaks down, you can easily continue your work on a different one a new developer joins the team, he can start doing actual work without too much trouble you stop working on the project, you can easily hand-over to someone else. Reproducible prod-environments are essential for keeping your sanity... There are multiple ways you can handle the creation of reproducible environments. I will not cover them in detail here, but reasonable choices are: docker which is probably the most flexible, but it also has a relatively steep learning curve. Nevertheless, learning at least the basics is really worth it. ansible which is useful when you work with VPS. conda which is the easiest to get started with, but it cannot really help you with Note: In production, you often use a combination of the above. E.g. you create a VPS, you use ansible or terraform in order to set it up, \"harden\" it and install plain docker or kubernetes which is what you actually use to run your code.","title":"Reproducible environments"},{"location":"02_reproducible_environment/#reproducible-environments","text":"","title":"Reproducible environments"},{"location":"02_reproducible_environment/#what-is-an-environment","text":"In the context we are discussing, setting up the environment means to make sure that all the non-python programs and libraries that you application needs are available. So, if your code is calling for example gdalinfo or pdflatex using subprocess , it is your job to make sure that the program is there. A crucial detail is that the environment should be reproducible . And this affects both the development environment and the production environment","title":"What is an environment?"},{"location":"02_reproducible_environment/#setup-a-reproducible-environment","text":"Reproducible dev-environments mean that in case: your laptop breaks down, you can easily continue your work on a different one a new developer joins the team, he can start doing actual work without too much trouble you stop working on the project, you can easily hand-over to someone else. Reproducible prod-environments are essential for keeping your sanity... There are multiple ways you can handle the creation of reproducible environments. I will not cover them in detail here, but reasonable choices are: docker which is probably the most flexible, but it also has a relatively steep learning curve. Nevertheless, learning at least the basics is really worth it. ansible which is useful when you work with VPS. conda which is the easiest to get started with, but it cannot really help you with Note: In production, you often use a combination of the above. E.g. you create a VPS, you use ansible or terraform in order to set it up, \"harden\" it and install plain docker or kubernetes which is what you actually use to run your code.","title":"Setup a reproducible environment"},{"location":"03_python_versions/","text":"Python Versions \u00b6 Which version of Python should I use? \u00b6 As of today (June 2020), if you start a new project , you should be using Python 3.8.2+ Python 3.7.2+ is OK too. Versions below 3.6 should be avoided since they lack support for numerous, backward incompatible, language features including: f-strings type annotations async support dataclasses When should I upgrade my Python version? \u00b6 When developing an application, upgrading the python version is not something that you are required to do. Often, it is perfectly fine to continue using an older version, especially, for applications that are not being actively developed. That being said though, if you continue to develop your application sticking to the older versions comes with certain drawbacks: you are potentially missing security enhancements you are missing new language features the more you postpone upgrading (e.g. if you skip a version or two) the more difficult is going to be to make the upgrade eventually. Upgrading python versions is something that you can schedule to do every 18-24 months and, to the extent that you have a comprehensive test suite, it can be a relatively painless experience. Using new python releases (i.e. X.Y.0 and X.Y.1 ) should be avoided since you may encounter various problems (e.g. missing wheel packages etc). So, wait until at least X.Y.2 comes out.","title":"Which Python version?"},{"location":"03_python_versions/#python-versions","text":"","title":"Python Versions"},{"location":"03_python_versions/#which-version-of-python-should-i-use","text":"As of today (June 2020), if you start a new project , you should be using Python 3.8.2+ Python 3.7.2+ is OK too. Versions below 3.6 should be avoided since they lack support for numerous, backward incompatible, language features including: f-strings type annotations async support dataclasses","title":"Which version of Python should I use?"},{"location":"03_python_versions/#when-should-i-upgrade-my-python-version","text":"When developing an application, upgrading the python version is not something that you are required to do. Often, it is perfectly fine to continue using an older version, especially, for applications that are not being actively developed. That being said though, if you continue to develop your application sticking to the older versions comes with certain drawbacks: you are potentially missing security enhancements you are missing new language features the more you postpone upgrading (e.g. if you skip a version or two) the more difficult is going to be to make the upgrade eventually. Upgrading python versions is something that you can schedule to do every 18-24 months and, to the extent that you have a comprehensive test suite, it can be a relatively painless experience. Using new python releases (i.e. X.Y.0 and X.Y.1 ) should be avoided since you may encounter various problems (e.g. missing wheel packages etc). So, wait until at least X.Y.2 comes out.","title":"When should I upgrade my Python version?"},{"location":"04_developing_python_applications/","text":"Developing python applications \u00b6","title":"Developing Python Applications"},{"location":"04_developing_python_applications/#developing-python-applications","text":"","title":"Developing python applications"},{"location":"05_installing_python_applications/","text":"Installing Python applications ? \u00b6 While developing you will very often need to make use of some python CLI application. Nevertheless, often these applications are not packaged for your distribution and/or if you use a server distro or an LTS distro, the packages might be ancient. Prime examples of such applications are: ansible docker-compose pgcli poetry invoke httpie There are multiple ways that you can install such applications. For good or for bad, not all of them are equal. What not to do? \u00b6 Unfortunately, some quite popular suggestion from the internet should be avoided : sudo pip install pip install --user apt install , yum install or any other distribution pacakge manager What is the problem with sudo pip install \u00b6 You should NEVER use sudo pip install . Unless you want to end up with a broken linux installation, that is. The problems is that by using sudo pip install you may override/replace files that were previously installed by apt . Moreover, you might upgrade some packages to versions that are not compatible with other packages that are currently installed. And don't forget that the Python is being used by the linux distribution itself. So whenever you run sudo pip install you run the risk of breaking your Linux distribution in ways that might not be apparent and which might bite you even years later! And the worst is that you will break something and you will have zero warning that you did break it. For example if you try to upgrade ubuntu 18.04 to 20.04 the upgrade might fail because the files you have under /usr are no longer managed by apt , because you updated a package with sudo pip install Recovering the system from sudo pip install is possible but it is not fun and you must know what you are doing. What is the problem with pip install --user \u00b6 pip install --user installs packages in ~/.local/lib/pythonX.Y/site-packages The problem is that pip does not do dependency resolution (in the future this is planned to change ). It just installs packages. For example: package A requires package K Version <2.0 package B requires package K Version >2.0 If you do pip install --user A you will also install K version 1.X. If you follow this command with pip install --user B , then K will be upgraded to version 2.X and A will be broken without any warnings . So, by using pip install --user you solve a short term problem but you might introduce other problems in the future that might be hard to debug. And anyhow, since there are way cleaner options, why use something suboptimal? How about installing stuff with my distro's package manager (e.g. apt or yum )? \u00b6 The package manager can work just fine as long as you stick it. There are some downsides though: not everything is available packages are often outdated most often than not you are forced to use a specific version As an application developper, I want to have the freedom to solve the problem I am facing in the best way possible. Fighting with old APIs is not helping in that direction. How about creating a virtualenv and installing the application there? \u00b6 This is by far the best option. You achieve complete isolation of the application both from other applications and from the system. Nevertheless, it is cumbersome: You need to create the virtual environment manually install the package manually create symlinks to ~/.local/bin manually you need to remember to remove the symlinks when you remove the application. Thankfully, there is a tool that automates the virtualenv procedure. It is called pipx . pipx ? \u00b6 pipx is a package that lets you Install and Run Python Applications in Isolated Environments. Installation \u00b6 pipx only has two requirements: Python 3.6+ ~/.local/bin must be in your $PATH To install it you should use: python3 -mpip install --user pipx yes, earlier, we suggested not to use pip install --user , but we will only be installing this very package with pip install --user . All the others will be installed by pipx itself. Usage \u00b6 Using pipx is pretty simple. you just run pipx install <package-name> where <package-name> is the name of any PyPi package. Behind the scenes, pipx will: Create a dedicated Virtual Environemnt in ~/.local/pipx/virtualenvs Install the application in the virtualenv Create a symlink from ~/.local/pipx/virtualenvs/<package_name>/bin/<executable> to ~/.local/bin To uninstall a package you just: pipx uninstall <package_name> and this will remove both the virtualenv and the symlink","title":"Installing Python Applications"},{"location":"05_installing_python_applications/#installing-python-applications","text":"While developing you will very often need to make use of some python CLI application. Nevertheless, often these applications are not packaged for your distribution and/or if you use a server distro or an LTS distro, the packages might be ancient. Prime examples of such applications are: ansible docker-compose pgcli poetry invoke httpie There are multiple ways that you can install such applications. For good or for bad, not all of them are equal.","title":"Installing Python applications?"},{"location":"05_installing_python_applications/#what-not-to-do","text":"Unfortunately, some quite popular suggestion from the internet should be avoided : sudo pip install pip install --user apt install , yum install or any other distribution pacakge manager","title":"What not to do?"},{"location":"05_installing_python_applications/#what-is-the-problem-with-sudo-pip-install","text":"You should NEVER use sudo pip install . Unless you want to end up with a broken linux installation, that is. The problems is that by using sudo pip install you may override/replace files that were previously installed by apt . Moreover, you might upgrade some packages to versions that are not compatible with other packages that are currently installed. And don't forget that the Python is being used by the linux distribution itself. So whenever you run sudo pip install you run the risk of breaking your Linux distribution in ways that might not be apparent and which might bite you even years later! And the worst is that you will break something and you will have zero warning that you did break it. For example if you try to upgrade ubuntu 18.04 to 20.04 the upgrade might fail because the files you have under /usr are no longer managed by apt , because you updated a package with sudo pip install Recovering the system from sudo pip install is possible but it is not fun and you must know what you are doing.","title":"What is the problem with sudo pip install"},{"location":"05_installing_python_applications/#what-is-the-problem-with-pip-install-user","text":"pip install --user installs packages in ~/.local/lib/pythonX.Y/site-packages The problem is that pip does not do dependency resolution (in the future this is planned to change ). It just installs packages. For example: package A requires package K Version <2.0 package B requires package K Version >2.0 If you do pip install --user A you will also install K version 1.X. If you follow this command with pip install --user B , then K will be upgraded to version 2.X and A will be broken without any warnings . So, by using pip install --user you solve a short term problem but you might introduce other problems in the future that might be hard to debug. And anyhow, since there are way cleaner options, why use something suboptimal?","title":"What is the problem with pip install --user"},{"location":"05_installing_python_applications/#how-about-installing-stuff-with-my-distros-package-manager-eg-apt-or-yum","text":"The package manager can work just fine as long as you stick it. There are some downsides though: not everything is available packages are often outdated most often than not you are forced to use a specific version As an application developper, I want to have the freedom to solve the problem I am facing in the best way possible. Fighting with old APIs is not helping in that direction.","title":"How about installing stuff with my distro's package manager (e.g. apt or yum)?"},{"location":"05_installing_python_applications/#how-about-creating-a-virtualenv-and-installing-the-application-there","text":"This is by far the best option. You achieve complete isolation of the application both from other applications and from the system. Nevertheless, it is cumbersome: You need to create the virtual environment manually install the package manually create symlinks to ~/.local/bin manually you need to remember to remove the symlinks when you remove the application. Thankfully, there is a tool that automates the virtualenv procedure. It is called pipx .","title":"How about creating a virtualenv and installing the application there?"},{"location":"05_installing_python_applications/#pipx","text":"pipx is a package that lets you Install and Run Python Applications in Isolated Environments.","title":"pipx?"},{"location":"05_installing_python_applications/#installation","text":"pipx only has two requirements: Python 3.6+ ~/.local/bin must be in your $PATH To install it you should use: python3 -mpip install --user pipx yes, earlier, we suggested not to use pip install --user , but we will only be installing this very package with pip install --user . All the others will be installed by pipx itself.","title":"Installation"},{"location":"05_installing_python_applications/#usage","text":"Using pipx is pretty simple. you just run pipx install <package-name> where <package-name> is the name of any PyPi package. Behind the scenes, pipx will: Create a dedicated Virtual Environemnt in ~/.local/pipx/virtualenvs Install the application in the virtualenv Create a symlink from ~/.local/pipx/virtualenvs/<package_name>/bin/<executable> to ~/.local/bin To uninstall a package you just: pipx uninstall <package_name> and this will remove both the virtualenv and the symlink","title":"Usage"},{"location":"app_conda/","text":"","title":"conda"}]}