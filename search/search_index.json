{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Suggestions for Python Development on Linux \u00b6 tl;dr \u00b6 The suggested setup is: Linux setup the environment in a reproducible way (e.g. using docker , ansible , conda , etc) Use a modern python version (3.6+) Create a virtualenv manage the python dependencies with poetry [Ooptional] install python cli applications using pipx Disclaimer \u00b6 First of all, a couple of definitions: A library is a provider of an API, i.e. code that gets imported by other libraries or applications An application is a consumer of APIs, i.e. code that imports other libraries The suggestions in this document are written from the point of view of the application developer. The requirements for library developers are different (more complex). Note: Obviously, the distinction made here is quite high level. You can have code that is both a library and an application, you can have a library where only part of the APi is public while the rest of the code is not meant to be imported, etc","title":"Home"},{"location":"#suggestions-for-python-development-on-linux","text":"","title":"Suggestions for Python Development on Linux"},{"location":"#tldr","text":"The suggested setup is: Linux setup the environment in a reproducible way (e.g. using docker , ansible , conda , etc) Use a modern python version (3.6+) Create a virtualenv manage the python dependencies with poetry [Ooptional] install python cli applications using pipx","title":"tl;dr"},{"location":"#disclaimer","text":"First of all, a couple of definitions: A library is a provider of an API, i.e. code that gets imported by other libraries or applications An application is a consumer of APIs, i.e. code that imports other libraries The suggestions in this document are written from the point of view of the application developer. The requirements for library developers are different (more complex). Note: Obviously, the distinction made here is quite high level. You can have code that is both a library and an application, you can have a library where only part of the APi is public while the rest of the code is not meant to be imported, etc","title":"Disclaimer"},{"location":"01_why_linux/","text":"Why linux? \u00b6 An important distinction is between: the development environment (i.e. where you write the code) the production environment (i.e. where you run the code) In order to make debugging easier, you should strive to make the development environment as similar as possible to the production environment Practically speaking, in science and web-development, the vast majority of the code that you will write will be executed on Linux (HPC, HTC, super-computers, web servers etc). So, use Linux!","title":"Why Linux?"},{"location":"01_why_linux/#why-linux","text":"An important distinction is between: the development environment (i.e. where you write the code) the production environment (i.e. where you run the code) In order to make debugging easier, you should strive to make the development environment as similar as possible to the production environment Practically speaking, in science and web-development, the vast majority of the code that you will write will be executed on Linux (HPC, HTC, super-computers, web servers etc). So, use Linux!","title":"Why linux?"},{"location":"02_reproducible_environment/","text":"Reproducible environments \u00b6 Setup a reproducible environment \u00b6 In the context we are discussing, setting up the environment means to make sure that all the non-python programs and libraries that you application needs are available. So, if your code is calling for example gdalinfo or pdflatex using subprocess , it is your job to make sure that the program is there. A crucial detail is that the environment should be reproducible . And this affects both the development environment and the production environment Reproducible dev-environments mean that in case: your laptop breaks down, you can easily continue your work on a different one a new developer joins the team, he can start doing actual work without too much trouble you stop working on the project, you can easily hand-over to someone else. Reproducible prod-environments are essential for keeping your sanity... There are multiple ways you can handle the creation of reproducible environments. I will not cover them in detail here, but reasonable choices are: docker which is probably the most flexible, but it also has a relatively steep learning curve. Nevertheless, learning at least the basics is really worth it. ansible which is useful when you work with VPS. conda which is the easiest to get started with, but it cannot really help you with Note: In production, you often use a combination of the above. E.g. you create a VPS, you use ansible or terraform in order to set it up, \"harden\" it and install plain docker or kubernetes which is what you actually use to run your code.","title":"Reproducible environments"},{"location":"02_reproducible_environment/#reproducible-environments","text":"","title":"Reproducible environments"},{"location":"02_reproducible_environment/#setup-a-reproducible-environment","text":"In the context we are discussing, setting up the environment means to make sure that all the non-python programs and libraries that you application needs are available. So, if your code is calling for example gdalinfo or pdflatex using subprocess , it is your job to make sure that the program is there. A crucial detail is that the environment should be reproducible . And this affects both the development environment and the production environment Reproducible dev-environments mean that in case: your laptop breaks down, you can easily continue your work on a different one a new developer joins the team, he can start doing actual work without too much trouble you stop working on the project, you can easily hand-over to someone else. Reproducible prod-environments are essential for keeping your sanity... There are multiple ways you can handle the creation of reproducible environments. I will not cover them in detail here, but reasonable choices are: docker which is probably the most flexible, but it also has a relatively steep learning curve. Nevertheless, learning at least the basics is really worth it. ansible which is useful when you work with VPS. conda which is the easiest to get started with, but it cannot really help you with Note: In production, you often use a combination of the above. E.g. you create a VPS, you use ansible or terraform in order to set it up, \"harden\" it and install plain docker or kubernetes which is what you actually use to run your code.","title":"Setup a reproducible environment"},{"location":"03_python_versions/","text":"Python Versions \u00b6 Which version of Python should I use? \u00b6 As of today (June 2020), if you start a new project , you should be using Python 3.8.2+ Python 3.7.2+ is OK too. Versions below 3.6 should be avoided since they lack support for numerous, backward incompatible, language features including: f-strings type annotations async support dataclasses When should I upgrade my Python version? \u00b6 When developing an application, upgrading the python version is not something that you are required to do. Often, it is perfectly fine to continue using an older version, especially, for applications that are not being actively developed. That being said though, if you continue to develop your application sticking to the older versions comes with certain drawbacks: you are potentially missing security enhancements you are missing new language features the more you postpone upgrading (e.g. if you skip a version or two) the more difficult is going to be to make the upgrade eventually. Upgrading python versions is something that you can schedule to do every 18-24 months and, to the extent that you have a comprehensive test suite, it can be a relatively painless experience. Using new python releases (i.e. X.Y.0 and X.Y.1 ) should be avoided since you may encounter various problems (e.g. missing wheel packages etc). So, wait until at least X.Y.2 comes out.","title":"Which Python version?"},{"location":"03_python_versions/#python-versions","text":"","title":"Python Versions"},{"location":"03_python_versions/#which-version-of-python-should-i-use","text":"As of today (June 2020), if you start a new project , you should be using Python 3.8.2+ Python 3.7.2+ is OK too. Versions below 3.6 should be avoided since they lack support for numerous, backward incompatible, language features including: f-strings type annotations async support dataclasses","title":"Which version of Python should I use?"},{"location":"03_python_versions/#when-should-i-upgrade-my-python-version","text":"When developing an application, upgrading the python version is not something that you are required to do. Often, it is perfectly fine to continue using an older version, especially, for applications that are not being actively developed. That being said though, if you continue to develop your application sticking to the older versions comes with certain drawbacks: you are potentially missing security enhancements you are missing new language features the more you postpone upgrading (e.g. if you skip a version or two) the more difficult is going to be to make the upgrade eventually. Upgrading python versions is something that you can schedule to do every 18-24 months and, to the extent that you have a comprehensive test suite, it can be a relatively painless experience. Using new python releases (i.e. X.Y.0 and X.Y.1 ) should be avoided since you may encounter various problems (e.g. missing wheel packages etc). So, wait until at least X.Y.2 comes out.","title":"When should I upgrade my Python version?"},{"location":"04_developing_python_applications/","text":"Developing python applications \u00b6","title":"Developing Python Applications"},{"location":"04_developing_python_applications/#developing-python-applications","text":"","title":"Developing python applications"},{"location":"05_installing_python_applications/","text":"Installing Python applications ? \u00b6 While developing you will very often need to make use of some python CLI application. Nevertheless, often these applications are not packaged for your distribution and/or if you use a server distro or an LTS distro, the packages might be ancient. Prime examples of such applications are: ansible docker-compose pgcli poetry invoke httpie There are multiple ways that you can install such applications. For good or for bad, not all of them are equal. What not to do? \u00b6 Unfortunately, some quite popular suggestion from the internet should be avoided : sudo pip install pip install --user apt install , yum install or any other distribution pacakge manager What is the problem with sudo pip install \u00b6 You should NEVER use sudo pip install . Unless you want to end up with a broken linux installation, that is. The problems is that by using sudo pip install you may override/replace files that were previously installed by apt . Moreover, you might upgrade some packages to versions that are not compatible with other packages that are currently installed. And don't forget that the Python is being used by the linux distribution itself. So whenever you run sudo pip install you run the risk of breaking your Linux distribution in ways that might not be apparent and which might bite you even years later! And the worst is that you will break something and you will have zero warning that you did break it. For example if you try to upgrade ubuntu 18.04 to 20.04 the upgrade might fail because the files you have under /usr are no longer managed by apt , because you updated a package with sudo pip install Recovering the system from sudo pip install is possible but it is not fun and you must know what you are doing. What is the problem with pip install --user \u00b6 pip install --user installs packages in ~/.local/lib/pythonX.Y/site-packages The problem is that pip does not do dependency resolution (in the future this is planned to change ). It just installs packages. For example: package A requires package K Version <2.0 package B requires package K Version >2.0 If you do pip install --user A you will also install K version 1.X. If you follow this command with pip install --user B , then K will be upgraded to version 2.X and A will be broken without any warnings . So, by using pip install --user you solve a short term problem but you might introduce other problems in the future that might be hard to debug. And anyhow, since there are way cleaner options, why use something suboptimal? How about installing stuff with my distro's package manager (e.g. apt or yum )? \u00b6 The package manager can work just fine as long as you stick it. There are some downsides though: not everything is available packages are often outdated most often than not you are forced to use a specific version As an application developper, I want to have the freedom to solve the problem I am facing in the best way possible. Fighting with old APIs is not helping in that direction. How about creating a virtualenv and installing the application there? \u00b6 This is by far the best option. You achieve complete isolation of the application both from other applications and from the system. Nevertheless, it is cumbersome: You need to create the virtual environment manually install the package manually create symlinks to ~/.local/bin manually you need to remember to remove the symlinks when you remove the application. Thankfully, there is a tool that automates the virtualenv procedure. It is called pipx . pipx ? \u00b6 pipx is a package that lets you Install and Run Python Applications in Isolated Environments. Installation \u00b6 pipx only has two requirements: Python 3.6+ ~/.local/bin must be in your $PATH To install it you should use: python3 -mpip install --user pipx yes, earlier, we suggested not to use pip install --user , but we will only be installing this very package with pip install --user . All the others will be installed by pipx itself. Usage \u00b6 Using pipx is pretty simple. you just run pipx install <package-name> where <package-name> is the name of any PyPi package. Behind the scenes, pipx will: Create a dedicated Virtual Environemnt in ~/.local/pipx/virtualenvs Install the application in the virtualenv Create a symlink from ~/.local/pipx/virtualenvs/<package_name>/bin/<executable> to ~/.local/bin To uninstall a package you just: pipx uninstall <package_name> and this will remove both the virtualenv and the symlink","title":"Installing Python Applications"},{"location":"05_installing_python_applications/#installing-python-applications","text":"While developing you will very often need to make use of some python CLI application. Nevertheless, often these applications are not packaged for your distribution and/or if you use a server distro or an LTS distro, the packages might be ancient. Prime examples of such applications are: ansible docker-compose pgcli poetry invoke httpie There are multiple ways that you can install such applications. For good or for bad, not all of them are equal.","title":"Installing Python applications?"},{"location":"05_installing_python_applications/#what-not-to-do","text":"Unfortunately, some quite popular suggestion from the internet should be avoided : sudo pip install pip install --user apt install , yum install or any other distribution pacakge manager","title":"What not to do?"},{"location":"05_installing_python_applications/#what-is-the-problem-with-sudo-pip-install","text":"You should NEVER use sudo pip install . Unless you want to end up with a broken linux installation, that is. The problems is that by using sudo pip install you may override/replace files that were previously installed by apt . Moreover, you might upgrade some packages to versions that are not compatible with other packages that are currently installed. And don't forget that the Python is being used by the linux distribution itself. So whenever you run sudo pip install you run the risk of breaking your Linux distribution in ways that might not be apparent and which might bite you even years later! And the worst is that you will break something and you will have zero warning that you did break it. For example if you try to upgrade ubuntu 18.04 to 20.04 the upgrade might fail because the files you have under /usr are no longer managed by apt , because you updated a package with sudo pip install Recovering the system from sudo pip install is possible but it is not fun and you must know what you are doing.","title":"What is the problem with sudo pip install"},{"location":"05_installing_python_applications/#what-is-the-problem-with-pip-install-user","text":"pip install --user installs packages in ~/.local/lib/pythonX.Y/site-packages The problem is that pip does not do dependency resolution (in the future this is planned to change ). It just installs packages. For example: package A requires package K Version <2.0 package B requires package K Version >2.0 If you do pip install --user A you will also install K version 1.X. If you follow this command with pip install --user B , then K will be upgraded to version 2.X and A will be broken without any warnings . So, by using pip install --user you solve a short term problem but you might introduce other problems in the future that might be hard to debug. And anyhow, since there are way cleaner options, why use something suboptimal?","title":"What is the problem with pip install --user"},{"location":"05_installing_python_applications/#how-about-installing-stuff-with-my-distros-package-manager-eg-apt-or-yum","text":"The package manager can work just fine as long as you stick it. There are some downsides though: not everything is available packages are often outdated most often than not you are forced to use a specific version As an application developper, I want to have the freedom to solve the problem I am facing in the best way possible. Fighting with old APIs is not helping in that direction.","title":"How about installing stuff with my distro's package manager (e.g. apt or yum)?"},{"location":"05_installing_python_applications/#how-about-creating-a-virtualenv-and-installing-the-application-there","text":"This is by far the best option. You achieve complete isolation of the application both from other applications and from the system. Nevertheless, it is cumbersome: You need to create the virtual environment manually install the package manually create symlinks to ~/.local/bin manually you need to remember to remove the symlinks when you remove the application. Thankfully, there is a tool that automates the virtualenv procedure. It is called pipx .","title":"How about creating a virtualenv and installing the application there?"},{"location":"05_installing_python_applications/#pipx","text":"pipx is a package that lets you Install and Run Python Applications in Isolated Environments.","title":"pipx?"},{"location":"05_installing_python_applications/#installation","text":"pipx only has two requirements: Python 3.6+ ~/.local/bin must be in your $PATH To install it you should use: python3 -mpip install --user pipx yes, earlier, we suggested not to use pip install --user , but we will only be installing this very package with pip install --user . All the others will be installed by pipx itself.","title":"Installation"},{"location":"05_installing_python_applications/#usage","text":"Using pipx is pretty simple. you just run pipx install <package-name> where <package-name> is the name of any PyPi package. Behind the scenes, pipx will: Create a dedicated Virtual Environemnt in ~/.local/pipx/virtualenvs Install the application in the virtualenv Create a symlink from ~/.local/pipx/virtualenvs/<package_name>/bin/<executable> to ~/.local/bin To uninstall a package you just: pipx uninstall <package_name> and this will remove both the virtualenv and the symlink","title":"Usage"},{"location":"app_conda/","text":"","title":"conda"}]}